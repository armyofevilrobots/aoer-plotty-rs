use aoer_plotty_rs::context::{typography::Typography, Context};
use aoer_plotty_rs::elements::point_field::*;
use aoer_plotty_rs::elements::CarlsonSmithTruchet;
use aoer_plotty_rs::geo_types::svg::Arrangement;
use aoer_plotty_rs::prelude::{
    CircleHatch, CrossHatch, FastHexHatch, GotoTenHatch, HatchPattern, LineHatch, NoHatch,
    RadiusHatch, SpiralDirection, SpiralHatch, TruchetHatch,
};
use geo::{Coord, CoordsIter, Geometry, GeometryCollection, MultiPolygon};
use geo_offset::Offset;
use geo_types::{coord, geometry, Rect};
use std::borrow::BorrowMut;
use std::path::Path;
use std::sync::{Arc, Mutex};

fn main() {
    let mut ctx = Context::new();

    let mut fields: Vec<Arc<Mutex<Box<dyn PointField>>>> = vec![Arc::new(Mutex::new(Box::new(
        PerlinPointField::new(12, 0.01, 0.05, 0.05),
    )))];

    for (i, field) in fields.iter().enumerate() {
        let mut field = field.clone();
        let rect: Rect<f64> = Rect::new(
            Coord {
                x: (i % 3) as f64 * 64. + 4.,
                y: (i / 3) as f64 * 72. + 4.,
            },
            Coord {
                x: (i % 3) as f64 * 64. + 56. + 4.,
                y: (i / 3) as f64 * 72. + 56. + 4.,
            },
        );
        // let field = field;
        field.lock().unwrap().borrow_mut().generate(&rect);
        // println!("My field has points: {:?}", field.lock().unwrap().points());
        let circles: Vec<Geometry> = field
            .lock()
            .unwrap()
            .borrow_mut()
            .points()
            .expect("Should be generated by now.")
            .iter()
            .map(|point| {
                point
                    .offset(0.5)
                    .expect("Should always be able to offset a point.")
                    .into()
            })
            .collect();
        let circles = Geometry::GeometryCollection(GeometryCollection::new_from(circles));
        // println!("CIRCLES: {:?}", circles);
        ctx.stroke("black")
            .fill("black")
            .pattern(NoHatch::gen())
            .pen(0.2)
            .geometry(&circles)
            .geometry(&Geometry::Rect(rect))
            .pen(0.2)
            .pattern(Arc::new(Box::new(NoHatch {})))
            .typography(
                &format!("{:?}", field.lock().unwrap().as_ref()),
                // &"FIELD".to_string(),
                (i % 3) as f64 * 64. + 4.,
                (i / 3) as f64 * 72. + 8. + 56.,
                &Typography::new().size(1.2),
            );
    }

    let svg = ctx
        .to_svg(&Arrangement::<f64>::unit(&Rect::<f64>::new(
            coord! {x:0.0, y:0.0},
            coord! {x:500.0, y:500.0},
        )))
        .unwrap();
    // Write it to the images folder, so we can use it as an example!
    // Write it out to /images/$THIS_EXAMPLE_FILE.svg
    let fname = Path::new(file!()).file_stem().unwrap().to_str().unwrap();
    svg::save(format!("images/{}.svg", fname), &svg).unwrap();
}
